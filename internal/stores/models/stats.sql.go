// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: stats.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDailyLeaderboard = `-- name: GetDailyLeaderboard :many
SELECT
    user_id,
    COUNT(*) AS cards_studied_today
FROM
    wordvault_cards
WHERE
    -- this query needs to be made more efficient; we can add a separate last_review
    -- column and keep it up to date.
    ((fsrs_card->>'LastReview')::timestamp AT TIME ZONE 'UTC' AT TIME ZONE 'America/Los_Angeles')::date =
        (NOW() AT TIME ZONE 'America/Los_Angeles')::date
GROUP BY
    user_id
ORDER BY
    cards_studied_today DESC
`

type GetDailyLeaderboardRow struct {
	UserID            int64
	CardsStudiedToday int64
}

func (q *Queries) GetDailyLeaderboard(ctx context.Context) ([]GetDailyLeaderboardRow, error) {
	rows, err := q.db.Query(ctx, getDailyLeaderboard)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetDailyLeaderboardRow
	for rows.Next() {
		var i GetDailyLeaderboardRow
		if err := rows.Scan(&i.UserID, &i.CardsStudiedToday); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDailyProgress = `-- name: GetDailyProgress :one
SELECT
    -- Count of new cards studied today
    SUM(CASE
        WHEN jsonb_array_length(review_log) = 1
        THEN 1
        ELSE 0
    END) AS new_cards,

    -- Count of reviewed cards studied today
    SUM(CASE
        WHEN jsonb_array_length(review_log) > 1
        THEN 1
        ELSE 0
    END) AS reviewed_cards,

    -- Rating breakdown for new cards
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) = 1
              AND (review_log->0->>'Rating')::int = 1
    ) AS new_rating_1,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) = 1
              AND (review_log->0->>'Rating')::int = 2
    ) AS new_rating_2,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) = 1
              AND (review_log->0->>'Rating')::int = 3
    ) AS new_rating_3,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) = 1
              AND (review_log->0->>'Rating')::int = 4
    ) AS new_rating_4,

    -- Rating breakdown for reviewed cards
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) > 1
              AND (review_log->-1->>'Rating')::int = 1
    ) AS reviewed_rating_1,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) > 1
              AND (review_log->-1->>'Rating')::int = 2
    ) AS reviewed_rating_2,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) > 1
              AND (review_log->-1->>'Rating')::int = 3
    ) AS reviewed_rating_3,
    COUNT(*) FILTER (
        WHERE jsonb_array_length(review_log) > 1
              AND (review_log->-1->>'Rating')::int = 4
    ) AS reviewed_rating_4
FROM
    wordvault_cards
WHERE
    user_id = $1
    AND ((fsrs_card->>'LastReview')::timestamp AT TIME ZONE 'UTC' AT TIME ZONE $2::text)::date = ($3::timestamptz AT TIME ZONE $2::text)::date
`

type GetDailyProgressParams struct {
	UserID   int64
	Timezone string
	Now      pgtype.Timestamptz
}

type GetDailyProgressRow struct {
	NewCards        int64
	ReviewedCards   int64
	NewRating1      int64
	NewRating2      int64
	NewRating3      int64
	NewRating4      int64
	ReviewedRating1 int64
	ReviewedRating2 int64
	ReviewedRating3 int64
	ReviewedRating4 int64
}

func (q *Queries) GetDailyProgress(ctx context.Context, arg GetDailyProgressParams) (GetDailyProgressRow, error) {
	row := q.db.QueryRow(ctx, getDailyProgress, arg.UserID, arg.Timezone, arg.Now)
	var i GetDailyProgressRow
	err := row.Scan(
		&i.NewCards,
		&i.ReviewedCards,
		&i.NewRating1,
		&i.NewRating2,
		&i.NewRating3,
		&i.NewRating4,
		&i.ReviewedRating1,
		&i.ReviewedRating2,
		&i.ReviewedRating3,
		&i.ReviewedRating4,
	)
	return i, err
}
